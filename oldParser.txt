	/******************STATEMENT TYPES*************************/

	public void forr(){
		match("for");

		match("OPEN_PARENTHESIS");

		expression();

		match("SEMICOLON");
		expression();
		match("SEMICOLON");
		expression();
		match("CLOSE_PARENTHESIS");

		block();
	}

	public void whilee(){
		match("while");

		match("OPEN_PARENTHESIS");
		expression();
		match("CLOSE_PARENTHESIS");

		block();
	}

	public void iff(){
		match("if");

		match("OPEN_PARENTHESIS");
		expression();
		match("CLOSE_PARENTHESIS");

		block();

		if(isElse()){
			match("else");
			block();
		}
	}

	public void type(){
		match("type");
		match("StringIdentifier");

		typeDescriptor();

		match("SEMICOLON");
	}

	public void func(){
		match("function");

		match("StringIdentifier");

		match("OPEN_PARENTHESIS");


		if(hasParams())
			params();



		match("CLOSE_PARENTHESIS");

		if(hasTypeDesc())
			typeDescriptor();

		block();

	}

	public void var(){
		if(currentTok.getTokenType().equals("static"))
			match("static");
		
		if(currentTok.getTokenType().equals("const"))
			match("const");

		match("var");
		match("StringIdentifier");

		//assignment case ELSE declaration case
		if(currentTok.getTokenType().equals("ASSIGNMENT_OPERATOR")){
			match("ASSIGNMENT_OPERATOR");
			expression();
		} 
		else 
			typeDescriptor();

		match("SEMICOLON");
	}


	/******************SUPPORT STATEMENTS*********************/

	public void typeDescriptor(){
		naTypeDescriptor();

		if(isDimensh())								//optional expression next?
			dimensh();								//parse it
	}

	public void naTypeDescriptor(){

		// record-descriptor ELSE IF identifier ELSE basic-type
		if(currentTok.getTokenType().equals("record")){
			match("record");
			fieldDeclarations();
			match("end");
		}
		else if(currentTok.getTokenType().equals("StringIdentifier")){
			match("StringIdentifier");
		}
		else{
			switch(currentTok.getTokenType()){
				case "byte" : 	match("byte"); break;
				case "int32": 	match("int32"); break;
				case "float64": match("float64"); break;
				default : break;
			}
		}
	}

	public void block(){
		match("OPEN_BRACE");
		
		while(!currentTok.getTokenType().equals("CLOSE_BRACE"))
			match();

		match("CLOSE_BRACE");
	}



		public void parameter(){
		if(currentTok.getTokenType().equals("ref"))
			match("ref");

		if(currentTok.getTokenType().equals("const"))
			match("const");

		match("StringIdentifier");

		if(currentTok.getTokenType().equals("ASSIGNMENT_OPERATOR")){
			match("ASSIGNMENT_OPERATOR");
			expression();
		}
		else{
			naTypeDescriptor();

			if(hasWilds()){
				match("OPEN_BRACKET");
				dimWilds();
				match("CLOSE_BRACKET");
			}
		}
	}

	public void params(){
		//ORIGINAL LEFT RECURSION : parameters ::= ( parameters , )* parameter
		//THIS IS SIMPIFIED FORM, IN NON-SIMPLIFIED FORM THE LEFT RECURSION IS
		//PARAMETERS -> PARAMETERS , PARAM || PARAM

		//TRANSLATED TO RIGHT RECURSION

		//PARAMETERS -> PARAM Z
		//         Z -> , PARAM Z || empty

		//example string (int x, int y, char z)
		//match(param); z(); 
		//public void z(){ if(currentTok != ','){ return; } match(comma); match(param); z(); }
		parameter();
		z();
	}

	public void z(){
		if(!currentTok.getTokenType().equals("COMMA")) return;

		match("COMMA");
		parameter();
		z();
	}